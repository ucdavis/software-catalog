name: Development Environment Test

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  test-dev-environment:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD_DEV }}
          POSTGRES_USER: postgres
          POSTGRES_DB: software-catalog
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Validate required secrets
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD_DEV }}
          AUTH_SECRET: ${{ secrets.AUTH_SECRET }}
          AUTH_DISCORD_ID: ${{ secrets.AUTH_DISCORD_ID }}
          AUTH_DISCORD_SECRET: ${{ secrets.AUTH_DISCORD_SECRET }}
        run: |
          echo "ðŸ” Validating required repository secrets..."

          if [ -z "$POSTGRES_PASSWORD" ]; then
            echo "âŒ POSTGRES_PASSWORD_DEV repository secret is not set"
            echo "Please add POSTGRES_PASSWORD_DEV to your repository secrets"
            exit 1
          fi

          if [ -z "$AUTH_SECRET" ]; then
            echo "âŒ AUTH_SECRET repository secret is not set"
            echo "Please add AUTH_SECRET to your repository secrets"
            exit 1
          fi

          if [ -z "$AUTH_DISCORD_ID" ]; then
            echo "âŒ AUTH_DISCORD_ID repository secret is not set"
            echo "Please add AUTH_DISCORD_ID to your repository secrets"
            exit 1
          fi

          if [ -z "$AUTH_DISCORD_SECRET" ]; then
            echo "âŒ AUTH_DISCORD_SECRET repository secret is not set"
            echo "Please add AUTH_DISCORD_SECRET to your repository secrets"
            exit 1
          fi

          echo "âœ… All required secrets are present"

      - name: Create .env file for testing
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD_DEV }}
          AUTH_SECRET: ${{ secrets.AUTH_SECRET }}
          AUTH_DISCORD_ID: ${{ secrets.AUTH_DISCORD_ID }}
          AUTH_DISCORD_SECRET: ${{ secrets.AUTH_DISCORD_SECRET }}
        run: |
          {
          cat > .env <<EOF
          # Test environment variables
          DATABASE_URL=postgresql://$POSTGRES_USER:$POSTGRES_PASSWORD@localhost:5432/software-catalog
          AUTH_SECRET=$AUTH_SECRET
          AUTH_DISCORD_ID=$AUTH_DISCORD_ID
          AUTH_DISCORD_SECRET=$AUTH_DISCORD_SECRET
          NODE_ENV=development
          NEXT_TELEMETRY_DISABLED=1
          EOF
          } >/dev/null

      - name: Make dev-setup.sh executable
        run: chmod +x ./dev-setup.sh

      - name: Start development environment
        run: |
          echo "ðŸš€ Starting development environment..."
          # Start the development environment in the background
          ./dev-setup.sh dev &
          DEV_PID=$!
          echo "Development environment started with PID: $DEV_PID"
          echo "DEV_PID=$DEV_PID" >> $GITHUB_ENV

      - name: Wait for application to be ready
        run: |
          set -euo pipefail
          echo "â³ Waiting for application to be ready on localhost:3000..."
          timeout=300  # 5 minutes timeout
          elapsed=0
          interval=10

          while [ $elapsed -lt $timeout ]; do
            if curl -f -s http://localhost:3000 > /dev/null 2>&1; then
              echo "âœ… Application is responding on localhost:3000"
              break
            fi

            echo "â³ Waiting... (${elapsed}s/${timeout}s)"
            sleep $interval
            elapsed=$((elapsed + interval))

            # Check if the development process is still running
            if ! kill -0 $DEV_PID 2>/dev/null; then
              echo "âŒ Development process has stopped unexpectedly"
              docker compose logs app-dev || true
              exit 1
            fi
          done

          if [ $elapsed -ge $timeout ]; then
            echo "âŒ Timeout: Application did not respond within \
              ${timeout} seconds"
            docker compose logs app-dev || true
            exit 1
          fi

      - name: Test application endpoints
        run: |
          echo "ðŸ§ª Testing application endpoints..."

          # Test root endpoint
          echo "Testing GET /"
            http_code=$(curl -s -o page.html -w "%{http_code}" http://localhost:3000)
            page_content=$(cat page.html)
            rm -f page.html

            if [ "$http_code" != "200" ]; then
            echo "âŒ Root endpoint failed with HTTP $http_code"
            echo "Response: $page_content"
            exit 1
            fi

          echo "âœ… Root endpoint responded with HTTP 200"

          # Test that the response contains expected content
          page_content=$(curl -s http://localhost:3000)
          if echo "$page_content" | grep -q "Next.js\|React\|software-catalog"; then
            echo "âœ… Page contains expected content"
          else
            echo "âš ï¸  Page content may not be as expected, but HTTP 200 received"
          fi

      - name: Test tRPC endpoint (if available)
        run: |
          echo "ðŸ”§ Testing tRPC endpoint..."
          # Test tRPC hello endpoint if it exists
          if curl -s -f "http://localhost:3000/api/trpc/post.hello" > /dev/null 2>&1; then
            echo "âœ… tRPC endpoint is accessible"
          else
            echo "â„¹ï¸  tRPC endpoint test skipped or not available"
          fi

      - name: Cleanup
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up..."
          # Stop the development environment
          if [ -n "$DEV_PID" ] && kill -0 $DEV_PID 2>/dev/null; then
            echo "Stopping development environment (PID: $DEV_PID)"
            kill $DEV_PID || true
          fi

          # Stop docker compose services
          docker compose down -v || true

          # Show logs for debugging if needed
          echo "ðŸ“‹ Final logs:"
          docker compose logs app-dev || true

      - name: Report success
        if: success()
        run: |
          echo "ðŸŽ‰ Development environment test completed successfully!"
          echo "âœ… Application started correctly"
          echo "âœ… HTTP endpoints are responding"
          echo "âœ… Development setup is working"
